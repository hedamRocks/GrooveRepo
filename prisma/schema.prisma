// schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ==========================================
// USER & AUTH
// ==========================================

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Discogs connection
  discogsUsername String?
  discogsToken    String? // Encrypted OAuth token

  // Import tracking
  lastImportAt     DateTime?
  lastImportStatus String? // "pending" | "in_progress" | "completed" | "failed"

  // Relations
  records         UserRecord[]
  shelves         Shelf[]
  magicLinkTokens MagicLinkToken[]
  analysisJobs    AnalysisJob[]
  tags            Tag[]
  setlists        Setlist[]

  @@index([email])
}

model MagicLinkToken {
  id        String   @id @default(cuid())
  token     String   @unique
  email     String
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime @default(now())

  user   User?   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String?

  @@index([token])
  @@index([email])
}

// ==========================================
// CANONICAL RELEASE DATA
// ==========================================
// Stores Discogs release metadata globally.
// Multiple users can reference the same release.
// Design accepts partial data - not all fields required.

model Release {
  id String @id @default(cuid())

  // Discogs linkage (optional - allows manual adds without full Discogs data)
  discogsId       Int?    @unique
  discogsMasterId Int? // For grouping pressings (future use)

  // Core metadata (all optional to support partial imports)
  title      String?
  artist     String? // Flattened artist string for search
  label      String?
  catNo      String?
  year       Int?
  country    String? // Release country
  genres     String[] // Array of genre strings
  styles     String[] // Array of style strings (more specific than genres)
  formats    String[] // ["Vinyl", "LP", "12\"", "33 â…“ RPM"] - flattened from format array
  coverUrl   String? // Primary cover image
  thumbUrl   String? // Thumbnail

  // Community/marketplace data from Discogs
  communityHave Int? // Number of users who have this release
  communityWant Int? // Number of users who want this release

  // Full Discogs response stored as JSON for future use
  // Includes: tracklist, credits, videos, identifiers, companies, etc.
  discogsData Json?

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  userRecords    UserRecord[]

  @@index([discogsId])
  @@index([artist]) // For search
  @@index([title])  // For search
}

// ==========================================
// USER-SPECIFIC OWNERSHIP DATA
// ==========================================
// Separates "what the record is" from "how I relate to it"
// This allows shared canonical data + personal context

model UserRecord {
  id String @id @default(cuid())

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  releaseId String
  release   Release @relation(fields: [releaseId], references: [id], onDelete: Cascade)

  // Personal data (all optional)
  notes String? // Free-text personal notes

  // Condition tracking (standard Discogs grading)
  // Values: "Mint (M)", "Near Mint (NM)", "Very Good Plus (VG+)", "Very Good (VG)", "Good Plus (G+)", "Good (G)", "Fair (F)", "Poor (P)"
  mediaCondition  String? // Vinyl/CD condition
  sleeveCondition String? // Cover/sleeve condition

  // Discogs collection import metadata
  addedToDiscogsAt DateTime? // When they added it to Discogs
  instanceId       Int? // Discogs collection instance ID (for sync/update)

  // Tags for custom organization
  tags    String[] // For future custom tagging

  // Timestamps
  addedAt   DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  shelfPlacements ShelfPlacement[]
  tracks          Track[]

  @@unique([userId, releaseId]) // User can only own a release once
  @@index([userId])
  @@index([addedAt]) // For "recently added" views
}

// ==========================================
// TRACKS
// ==========================================
// Individual tracks on a record (A1, A2, B1, B2, etc.)
// DJ metadata lives here since each track has unique BPM/key/energy

model Track {
  id String @id // Format: {userRecordId}_{position} (e.g. "rec_abc123_A1")

  userRecordId String
  userRecord   UserRecord @relation(fields: [userRecordId], references: [id], onDelete: Cascade)

  // Track identity
  position String  // e.g. "A1", "A2", "B1", "B2"
  title    String  // Track title
  duration String? // Duration string (e.g. "4:23")

  // DJ Metadata (analyzed per-track)
  bpm        Int?
  key        String? // e.g. "D minor", "C major"
  energy     Int?    // 0-10 scale
  confidence Float?  // 0.0-1.0 analysis confidence

  // YouTube source for analysis
  youtubeId    String?
  youtubeTitle String?

  // Timestamps
  analyzedAt DateTime?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  // Relations
  trackTags      TrackTag[]
  setlistTracks  SetlistTrack[]

  @@unique([userRecordId, position]) // Each track position unique per record
  @@index([userRecordId])
  @@index([bpm]) // For BPM filtering/sorting
  @@index([key]) // For key filtering
}

// ==========================================
// SHELVES (Simple Grouping)
// ==========================================

model Shelf {
  id          String   @id @default(cuid())
  name        String
  description String?
  color       String? // Hex color for visual distinction
  sortOrder   Int      @default(0) // User-defined shelf order

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  placements ShelfPlacement[]

  @@index([userId])
  @@index([sortOrder])
}

// Join table: Many-to-many between UserRecords and Shelves
// A record can be on multiple shelves
model ShelfPlacement {
  id String @id @default(cuid())

  userRecordId String
  userRecord   UserRecord @relation(fields: [userRecordId], references: [id], onDelete: Cascade)

  shelfId String
  shelf   Shelf  @relation(fields: [shelfId], references: [id], onDelete: Cascade)

  addedAt DateTime @default(now())

  @@unique([userRecordId, shelfId]) // Can't add same record to same shelf twice
  @@index([shelfId])
  @@index([userRecordId])
}

// ==========================================
// BACKGROUND JOB TRACKING
// ==========================================
// Tracks long-running Discogs imports
// Allows UI to poll for progress without blocking

model ImportJob {
  id String @id @default(cuid())

  userId String
  type   String // "discogs_collection_full" | "discogs_collection_delta"

  status String @default("pending") // "pending" | "in_progress" | "completed" | "failed"

  // Progress tracking
  totalItems     Int?
  processedItems Int      @default(0)
  failedItems    Int      @default(0)

  // Error handling
  errorMessage String?
  errorDetails Json?

  // Timestamps
  startedAt   DateTime?
  completedAt DateTime?
  createdAt   DateTime  @default(now())

  @@index([userId])
  @@index([status])
  @@index([createdAt])
}

// ==========================================
// DJ METADATA ANALYSIS
// ==========================================

model AnalysisJob {
  id           String   @id @default(cuid())
  userId       String
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Job configuration
  type         String   // "full_library" | "selected_records" | "selected_tracks"
  recordIds    String[] // If type = "selected_records"
  trackIds     String[] // If type = "selected_tracks"

  // Status tracking
  status       String   // "pending" | "in_progress" | "completed" | "failed"
  totalTracks  Int      @default(0)
  processed    Int      @default(0)
  failed       Int      @default(0)

  // Error handling
  errorMessage String?
  errors       Json?    // Array of { trackId, error, timestamp }

  // Timestamps
  startedAt    DateTime?
  completedAt  DateTime?
  createdAt    DateTime  @default(now())

  @@index([userId])
  @@index([status])
  @@index([createdAt])
}

// ==========================================
// CUSTOM TAGS
// ==========================================
// User-defined tags for organizing tracks

model Tag {
  id          String   @id @default(cuid())
  name        String
  color       String? // Hex color for visual distinction
  description String?

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  trackTags TrackTag[]

  @@unique([userId, name]) // Tag names must be unique per user
  @@index([userId])
}

// Join table: Many-to-many between Tracks and Tags
model TrackTag {
  id String @id @default(cuid())

  trackId String
  track   Track  @relation(fields: [trackId], references: [id], onDelete: Cascade)

  tagId String
  tag   Tag    @relation(fields: [tagId], references: [id], onDelete: Cascade)

  addedAt DateTime @default(now())

  @@unique([trackId, tagId]) // Can't add same tag to same track twice
  @@index([trackId])
  @@index([tagId])
}

// ==========================================
// SETLISTS
// ==========================================
// DJ setlists/playlists with ordered tracks

model Setlist {
  id          String   @id @default(cuid())
  name        String
  description String?
  venue       String? // Where this setlist was/will be played
  date        DateTime? // Event date
  duration    Int? // Total duration in seconds

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  tracks SetlistTrack[]

  @@index([userId])
  @@index([date])
}

// Join table: Tracks in setlists with ordering
model SetlistTrack {
  id String @id @default(cuid())

  setlistId String
  setlist   Setlist @relation(fields: [setlistId], references: [id], onDelete: Cascade)

  trackId String
  track   Track  @relation(fields: [trackId], references: [id], onDelete: Cascade)

  // Ordering and manual overrides
  sortOrder  Int // Position in setlist (0-indexed)
  manualBpm  Int? // Manual BPM override for this track
  notes      String? // Per-setlist track notes

  addedAt DateTime @default(now())

  @@unique([setlistId, trackId]) // Can't add same track to same setlist twice
  @@unique([setlistId, sortOrder]) // Each position unique per setlist
  @@index([setlistId])
  @@index([trackId])
}
